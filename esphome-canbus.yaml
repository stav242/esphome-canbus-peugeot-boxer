substitutions:
  name: "esphome-canbus"
  friendly_name: ESPHome CANbus
  builtin_led_pin: "GPIO2"

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2024.6.0
  name_add_mac_suffix: false
  project:
    name: esphome.web
    version: dev

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: INFO

time:
  - platform: homeassistant
    id: homeassistant_time

api:
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

web_server:

# Defines the physical LED output
output:
  - platform: gpio
    pin: ${builtin_led_pin}
    id: builtin_led_output
    inverted: true

# Non-blocking script to handle the LED flashing
script:
  - id: flash_can_led
    mode: restart
    then:
      - lambda: |-
          id(builtin_led_output)->turn_on();
          App.scheduler.set_timeout(id(builtin_led_output), "led_off_timer", 50, [] {
            id(builtin_led_output)->turn_off();
          });

canbus:
  - platform: esp32_can
    id: my_canbus
    tx_pin: GPIO01
    rx_pin: GPIO03
    bit_rate: 50kbps
    use_extended_id: true
    can_id: 0x0
    on_frame:
      # Throttle_Position (ID:0x04394100)
      - can_id: 0x04394100
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              if (x.size() >= 4) {
                uint16_t throttle_raw = x[3];
                float throttle_position_percent = (float)throttle_raw / 2.55f;
                id(throttle_position).publish_state(throttle_position_percent);
              }

      # Doors, Hazard Lights (ID:0x06214000)
      - can_id: 0x06214000
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              if (x.size() >= 3) {
                const char *TAG = "can_0x06214000";
                bool rear_sliding_door_open = (x[1] & 0x30) == 0x30;
                id(RearSlidingDoor_Status).publish_state(rear_sliding_door_open);
                ESP_LOGI(TAG, "RearSlidingDoor: %s (Byte1 data: 0x%02X)", rear_sliding_door_open ? "OPEN" : "CLOSED", x[1]);
                bool rear_doors_open = (x[1] & 0x40) == 0x40;
                id(RearDoors_Status).publish_state(rear_doors_open);
                ESP_LOGI(TAG, "RearDoors: %s (Byte1 data: 0x%02X)", rear_doors_open ? "OPEN" : "CLOSED", x[1]);
                bool hazard_lights_on = (x[2] & 0x60) == 0x60;
                id(HazardLights_Status).publish_state(hazard_lights_on);
                ESP_LOGI(TAG, "HazardLights: %s (Byte2 data: 0x%02X)", hazard_lights_on ? "ON" : "OFF", x[2]);
              } else {
                ESP_LOGW("can_0x06214000", "Frame 0x06214000 too short, size: %d.", x.size());
              }

      # Key Fob (ID:0x02294000)
      - can_id: 0x02294000
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              if (x.size() >= 7) {
                bool fob_lock_pressed = (x[5] & 0x80) == 0x80;
                id(Fob_Lock_Doors_Button).publish_state(fob_lock_pressed);
                if (fob_lock_pressed) id(door_status).publish_state("locked");
                bool fob_unlock_front_pressed = (x[5] & 0x08) == 0x08;
                id(Fob_Unlock_FrontDoors_Button).publish_state(fob_unlock_front_pressed);
                if (fob_unlock_front_pressed) id(door_status).publish_state("unlocked");
                bool fob_unlock_rear_pressed = (x[6] & 0x80) == 0x80;
                id(Fob_Unlock_RearDoors_Button).publish_state(fob_unlock_rear_pressed);
                if (fob_unlock_rear_pressed) id(door_status).publish_state("unlocked");
                bool fob_deadlock_pressed = (x[5] & 0x40) == 0x40;
                id(Fob_Deadlock_Doors_Button).publish_state(fob_deadlock_pressed);
                if (fob_deadlock_pressed) id(door_status).publish_state("deadlocked");
              }

      # Media (ID:0x06284000)
      - can_id: 0x06284000
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              if (x.size() >= 2) {
                id(Media_Volume_Up_Button).publish_state((x[0] & 0x80) == 0x80);
                id(Media_Volume_Down_Button).publish_state((x[0] & 0x40) == 0x40);
                id(Media_Mute_Button).publish_state((x[0] & 0x20) == 0x20);
                id(Media_Talk_Button).publish_state((x[1] & 0x40) == 0x40);
                id(Media_Select_Up_Button).publish_state((x[0] & 0x10) == 0x10);
                id(Media_Select_Down_Button).publish_state((x[0] & 0x08) == 0x08);
                id(Media_Phone_Call_Button).publish_state((x[0] & 0x02) == 0x02);
                id(Media_Phone_Hangup_Button).publish_state((x[0] & 0x01) == 0x01);
              }

      # Indicators, Brake Pedal & Headlights (ID:0x02214000)
      - can_id: 0x02214000
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              if (x.size() >= 3) {
                const char *TAG = "can_0x02214000";
                id(Indicator_Left).publish_state((x[2] & 0x40) == 0x40);
                id(Indicator_Right).publish_state((x[2] & 0x20) == 0x20);
                id(brake_pedal).publish_state((x[0] & 0x80) == 0x80);
                bool headlights_on = (x[1] & 0x68) == 0x68;
                id(Headlights_Status).publish_state(headlights_on);
                ESP_LOGI(TAG, "Headlights: %s (Byte1 data: 0x%02X)", headlights_on ? "ON" : "OFF", x[1]);
              }

      # Parking Brake & Ignition (ID:0x06314003)
      - can_id: 0x06314003
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              if (x.size() >= 7) {
                id(parking_brake).publish_state((x[0] & 0x20) == 0x20);
                id(ignition_on).publish_state((x[6] & 0x40) == 0x40);
              }

      # Date & Time (ID:0x0C214003)
      - can_id: 0x0C214003
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              if (x.size() >= 6) {
                char date_str[11];
                snprintf(date_str, sizeof(date_str), "%02X/%02X/%02X%02X", x[2], x[3], x[4], x[5]);
                char time_str[6];
                snprintf(time_str, sizeof(time_str), "%02X:%02X", x[0], x[1]);
                id(can_bus_date).publish_state(date_str);
                id(can_bus_time).publish_state(time_str);
                ESP_LOGD("can_bus_datetime", "Received CAN Date: %s, Time: %s", date_str, time_str);
              } else {
                ESP_LOGW("can_bus_datetime", "CAN Date/Time message too short. Got %zu bytes.", x.size());
              }

      # Exterior Temp (ID:0x063d4000)
      - can_id: 0x063d4000
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              if (x.size() >= 1) {
                uint8_t exterior_temp_raw = x[0];
                float exterior_temp_celsius = (float)exterior_temp_raw - 84.0f;
                id(exterior_temp).publish_state(exterior_temp_celsius);
              }

      # VIN Number (ID: 0x03254000)
      - can_id: 0x03254000
        use_extended_id: true
        then:
          - script.execute: flash_can_led
          - lambda: |-
              static char vin_str_buffer[18];
              static uint8_t vin_bytes_collected = 0;
              static uint32_t last_vin_frame_millis = 0;
              // CORRECTED: Increased timeout to 15 seconds
              const uint32_t VIN_FRAME_PART_TIMEOUT_MS = 15000;
              const char *TAG = "vin_decoder";

              if (x.empty()) {
                ESP_LOGW(TAG, "ID 0x03254000: Received empty frame.");
                return;
              }
              uint32_t current_millis = millis();
              
              if (vin_bytes_collected > 0 && (current_millis - last_vin_frame_millis > VIN_FRAME_PART_TIMEOUT_MS)) {
                ESP_LOGW(TAG, "Timeout! Resetting VIN buffer (had %d bytes collected).", vin_bytes_collected);
                vin_bytes_collected = 0;
              }

              if (vin_bytes_collected == 0) {
                memset(vin_str_buffer, 0, sizeof(vin_str_buffer));
              }

              if (x.size() > 1) {
                for (size_t i = 1; i < x.size(); ++i) {
                  if (vin_bytes_collected < 17) {
                    char ch = (char)x[i];
                    if (isprint(ch)) {
                      vin_str_buffer[vin_bytes_collected] = ch;
                      vin_bytes_collected++;
                    }
                  }
                }
              }
              
              last_vin_frame_millis = current_millis;

              if (vin_bytes_collected >= 17) {
                vin_str_buffer[17] = '\0';
                id(vehicle_vin).publish_state(vin_str_buffer);
                ESP_LOGI(TAG, "Full VIN collected and published: '%s'", vin_str_buffer);
                vin_bytes_collected = 0;
              }
sensor:
  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"
    unit_of_measurement: "dB"

  - platform: copy
    source_id: wifi_signal_db
    name: "WiFi Signal Percent"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    accuracy_decimals: 0
    entity_category: "diagnostic"

  - platform: uptime
    name: "ESPHome Uptime"
    entity_category: "diagnostic"

  - platform: template
    name: "Engine RPM"
    id: engine_rpm
    unit_of_measurement: "rpm"
    accuracy_decimals: 0
    icon: "mdi:gauge"

  - platform: template
    name: "Fuel Level"
    id: fuel_level
    unit_of_measurement: "%"
    accuracy_decimals: 1
    icon: "mdi:gas-station"

  - platform: template
    name: "Throttle Position"
    id: throttle_position
    unit_of_measurement: "%"
    accuracy_decimals: 1
    icon: "mdi:angle-acute"

  - platform: template
    name: "Vehicle Speed"
    id: Vehicle_Speed
    unit_of_measurement: "mph"
    accuracy_decimals: 1
    icon: "mdi:speedometer"

  - platform: template
    name: "Engine MAF"
    id: Engine_MAF
    unit_of_measurement: "g/s"
    accuracy_decimals: 2
    icon: "mdi:air-filter"

  - platform: template
    name: "Odometer"
    id: odometer
    unit_of_measurement: "mi"
    accuracy_decimals: 1
    icon: "mdi:counter"

  - platform: template
    name: "Coolant Temp"
    id: coolant_temp
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    device_class: "temperature"
    icon: "mdi:coolant-temperature"

  - platform: template
    name: "Exterior Temp"
    id: exterior_temp
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    device_class: "temperature"
    icon: "mdi:thermometer"

binary_sensor:
  - platform: status
    name: "ESPHome Status"
    entity_category: "diagnostic"

  - platform: template
    name: "Headlight Status"
    id: Headlights_Status
    device_class: light

  - platform: template
    name: "Rear Doors Status"
    id: RearDoors_Status
    device_class: door

  - platform: template
    name: "Rear SlidingDoor Status"
    id: RearSlidingDoor_Status
    device_class: door

  - platform: template
    name: "FrontDoor Status"
    id: FrontDoor_Status
    device_class: door

  - platform: template
    name: "HazardLight Status"
    id: HazardLights_Status
    device_class: light

  - platform: template
    name: "Fob Unlock FrontDoors Button"
    id: Fob_Unlock_FrontDoors_Button

  - platform: template
    name: "Fob Unlock RearDoors Button"
    id: Fob_Unlock_RearDoors_Button

  - platform: template
    name: "Fob Lock Doors Button"
    id: Fob_Lock_Doors_Button

  - platform: template
    name: "Fob DeadLock Doors Button"
    id: Fob_Deadlock_Doors_Button

  - platform: template
    name: "Media Volume Up Button"
    id: Media_Volume_Up_Button

  - platform: template
    name: "Media Volume Down Button"
    id: Media_Volume_Down_Button

  - platform: template
    name: "Media Mute Button"
    id: Media_Mute_Button

  - platform: template
    name: "Media Talk Button"
    id: Media_Talk_Button

  - platform: template
    name: "Media Select Up Button"
    id: Media_Select_Up_Button

  - platform: template
    name: "Media Select Down Button"
    id: Media_Select_Down_Button

  - platform: template
    name: "Media Phone Call Button"
    id: Media_Phone_Call_Button

  - platform: template
    name: "Media Phone Hangup Button"
    id: Media_Phone_Hangup_Button

  - platform: template
    name: "Indicator Left"
    id: Indicator_Left
    device_class: light

  - platform: template
    name: "Indicator Right"
    id: Indicator_Right
    device_class: light

  - platform: template
    name: "Parking Brake"
    id: parking_brake
    device_class: problem

  - platform: template
    name: "Brake Pedal"
    id: brake_pedal
    device_class: problem

  - platform: template
    name: "Key Present"
    id: key_present
    device_class: presence

  - platform: template
    name: "Ignition On"
    id: ignition_on
    device_class: power

text_sensor:
  - platform: template
    name: "Door Status"
    id: door_status
    icon: "mdi:door-closed-lock"

  - platform: template
    name: "CAN Bus Time"
    id: can_bus_time
    icon: "mdi:clock-outline"

  - platform: template
    name: "CAN Bus Date"
    id: can_bus_date
    icon: "mdi:calendar"

  - platform: template
    name: "Vehicle VIN"
    id: vehicle_vin
    icon: "mdi:car-info"

  - platform: version
    name: "ESPHome Version"
    entity_category: "diagnostic"
    hide_timestamp: true

  - platform: wifi_info
    ip_address:
      name: "ESP IP Address"
      entity_category: "diagnostic"
    ssid:
      name: "ESP Connected SSID"
      entity_category: "diagnostic"
    mac_address:
      name: "ESP Mac Wifi Address"
      entity_category: "diagnostic"

button:
  - platform: restart
    name: "Restart ESPHome"
    entity_category: "config"
    icon: "mdi:restart"

  - platform: template
    name: "Sync Time to CAN Bus"
    icon: "mdi:clock-sync-outline"
    entity_category: "config"
    on_press:
      then:
        - lambda: |-
            auto dec_to_bcd = [](uint8_t val) -> uint8_t {
              return ((val / 10) << 4) | (val % 10);
            };
            auto time_val = id(homeassistant_time).now();
            if (!time_val.is_valid()) {
              ESP_LOGW("canbus_sync_time", "Home Assistant time not available.");
              return;
            }
            uint8_t hour_bcd = dec_to_bcd(time_val.hour);
            uint8_t minute_bcd = dec_to_bcd(time_val.minute);
            uint8_t day_bcd = dec_to_bcd(time_val.day_of_month);
            uint8_t month_bcd = dec_to_bcd(time_val.month);
            uint8_t year_of_century = time_val.year % 100;
            uint8_t century = time_val.year / 100;
            uint8_t year_high_bcd = dec_to_bcd(century);
            uint8_t year_low_bcd = dec_to_bcd(year_of_century);
            
            uint8_t data_payload[] = {
              hour_bcd, minute_bcd, day_bcd, month_bcd, year_high_bcd, year_low_bcd
            };
            
            id(my_canbus).send_data(0x0C214024, true, false, std::vector<unsigned char>(data_payload, data_payload + sizeof(data_payload)));
            ESP_LOGI("canbus_sync_time", "Time sync CAN frame sent.");
